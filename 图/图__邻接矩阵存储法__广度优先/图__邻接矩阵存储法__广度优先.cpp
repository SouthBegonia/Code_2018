/*
	程序原理：应用图的邻接矩阵储存法，打印出检索各元素的顺序。
	广度优先遍历：首先以一个未被访问过的顶点作为起始点，访问其所有相邻的顶点，然后对每个相邻的顶点，再访问他们相邻的未被访问过的顶点，直到所有顶点被访问过。

*/
#include<stdio.h>
int main()
{
	int i, n = 5, m = 5, a, b, cur, book[101] = { 0 };
	int que[10001], head, tail;
	int e[101][101] = {
		{ 0,0,0,0,0,0 },
		{ 0,0,1,1,999999,1 },
		{ 0,1,0,999999,1,999999 },
		{ 0,1,999999,0,999999,1 },
		{ 0,999999,1,999999,0,999999 },
		{ 0,1,999999,1,999999,0 },
		/*
		二维数组构成的图见 Codes_2018/图/图__邻接矩阵__1.jpg
		构成的图见 Codes_2018/图/图__邻接矩阵__2.jpg
		*/
	};
	/* 无向图，二维数组已经预先设置
	e[a][b] = 1;
	e[b][a] = 1;
	*/
	head = 1, tail = 1;
	que[tail] = 1;												// 从1号元素出发
	tail++;
	book[1] = 1;												// 标记1号元素

	while (head < tail)
	{
		cur = que[head];										// 当前访问的元素的序号
		for (i = 1; i <= n; i++)
		{
			if (e[cur][i] == 1 && book[i] == 0)
			{
				que[tail] = i;
				tail++;
				book[i] = 1;
			}
			if (tail > n)										// 当所有顶点被访问过后，tail等于n+1，则退出
			{
				break;
			}
		}
		head++;													// 一个顶点扩展完后，进行下一个点的扩展
	}
	for (i = 1; i < tail; i++)
		printf("%d ", que[i]);

	getchar();
	getchar();
	return 0;

}