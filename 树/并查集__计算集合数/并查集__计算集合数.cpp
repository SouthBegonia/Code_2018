/*
	程序功能：给定n(10)个罪犯，m(9)条互为团伙信息，计算出有几个不同的团伙，即计算几个不同的集合。
*/
#include<stdio.h>
int f[1000] = { 0 }, n, m, k, sum = 0;

/*
	init():初始化存储罪犯信息的数组f[]，f[]序号i为罪犯序号，其数值 f[i] 表示该罪犯与序号为 f[i] 的罪犯同伙。
*/
void init()
{
	int i;
	for (i = 1; i <= n; i++)
		f[i] = i;
}
/*
	getf():返回 v 号罪犯的头目的数值
*/
int getf(int v)
{
	if (f[v] == v)
		return v;
	else
	{
		f[v] = getf(f[v]);
		return f[v];
	}
}
/*	
	merge():合并两个集合的函数	
*/
void merge(int v, int u)
{
	int t1, t2;
	t1 = getf(v);										// 寻找 v 和 u 号罪犯的头目 
	t2 = getf(u);
	if (t1 != t2)										// 判断两个结点是否在同一集合，即是否为同一头目
	{
		f[t2] = t1;										// 靠左原则，左边编程右边的头目，即把右边的集合作为左边集合的子集
	}
}
int main()
{
	int x, y, i;
	scanf_s("%d %d", &n, &m);							// 罪犯 n 人，信息 m 条

	init();												// 初始化f[]
	for (i = 1; i <= m; i++)
	{
		scanf_s("%d %d", &x, &y);						// 信息：x 与 y 同伙
		merge(x, y);									// 开始合并集合
	}
	/*	疑惑点：该验证方法的原理。*/
	for (i = 1; i <= n; i++)
	{
		if (f[i] == i)
			sum++;
	}
	printf("集合数为：%d\n", sum);
	printf("f[%d]= ", n);
	for(i=1;i<=n;i++)
		printf("%d ", f[i]);
	getchar();
	getchar();
	return 0;
}
/*	例1：团伙信息:(头目在首)[5 2 1 3 4 6][9 7 8][10] (有10号罪犯，但没有同伙信息，故独立成组织）
	输入：
			10 9
			1 2
			3 4
			5 2
			4 6
			2 6
			8 7
			9 7
			1 6
			2 4
	输出：集合数为：3
		  f[1~9]={5 5 5 5 5 5 8 9 9 10}
	解析：满足 f[i]=i 的有5，9,10 共3个，sum=3；
			从f[]数据来看，虽然看上去头目为 f[i]=i 的数，但本例纯属巧合，仅组织数正确，看例2。
			
	例2：团伙信息:(头目在首)[1 8 9][3 2 4][6 5 7]
	输入：
			9 6
			8 1
			1 9
			2 3
			3 4
			6 5
			7 6
	输出：集合数为：3
		  f[1~9]={8 2 2 2 6 7 7 8 8}
	解析：满足 f[i]=i 的有2、7、8 共3个，sum=3；
			但头目显然也不是2、7、8，且数字的种类也不是3种，即从f[]中无法判断三个组织的成员。

	总结：本算法有缺陷，仅可计算合集数，合集信息需其他方法探索。
*/