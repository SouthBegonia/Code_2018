/*
	程序原理：以深度优先算法计算奥数填空 [][][]+[][][]=[][][]，要求每个数字只用一次。
	深度优先搜索应用：当前盒子已经放入数字，尝试下一个盒子直到走到第10个盒子（不存在的）。
		补充：还是可以看出该算法特性：算出所有可能，选出最有解。
*/
#include<stdio.h>
int a[10], book[10], total = 0;            // a[10]表示9个盒子对应奥数公式的空，book[]标记每个数字的出现

void dfs(int step)                         // step表示站在第几个盒子前
{
	int i;
	if (step == 10)                        //表示前9个盒子都已填入数字
	{
		if (a[1] * 100 + a[2] * 10 + a[3] + a[4] * 100 + a[5] * 10 + a[6] == a[7] * 100 + a[8] * 10 + a[9])
		{
			total++;
			printf("%d%d%d+%d%d%d=%d%d%d\n", a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9]);
		}
		return;
	}

	for (i = 1; i <= 9; i++)                //对9个数字进行枚举（依旧按照1~9优先顺序）
	{
		if (book[i] == 0)                   //当该数字可用，则尝试
		{
			a[step] = i;                    //数字 i 放入盒子 step
			book[i] = 1;                    //标记该数字 i 已经用过

			dfs(step + 1);                  //走到下一格子

			book[i] = 0;                    //取消标记
		}
	}
	return;
}

int main()
{
	dfs(1);

	printf("total=%d\n", total/2);
	getchar();
	getchar();
	return 0;
}