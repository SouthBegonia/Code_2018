/*
	程序原理：用深度优先搜索替代枚举法解决炸弹人游戏。
*/
#include<stdio.h>
char a[20][21] = {
	//0	  1   2   3   4   5   6   7   8   9   10  11  12
	{ '#','#','#','#','#','#','#','#','#','#','#','#','#' },        //0
	{ '#','G','G','.','G','G','G','#','G','G','G','.','#' },        //1
	{ '#','#','#','.','#','G','#','G','#','G','#','G','#' },		//2
	{ '#','.','.','.','.','.','.','.','#','.','.','G','#' },		//3
	{ '#','G','#','.','#','#','#','.','#','G','#','G','#' },		//4
	{ '#','G','G','.','G','G','G','.','#','.','G','G','#' },		//5
	{ '#','G','#','.','#','G','#','.','#','.','#','.','#' },		//6
	{ '#','#','G','.','.','.','G','.','.','.','.','.','#' },		//7
	{ '#','G','#','.','#','G','#','#','#','.','#','G','#' },		//8
	{ '#','.','.','.','G','#','G','G','G','.','G','G','#' },		//9
	{ '#','G','#','.','#','G','#','G','#','.','#','G','#' },		//10
	{ '#','G','G','.','G','G','G','#','G','.','G','G','#' },		//11
	{ '#','#','#','#','#','#','#','#','#','#','#','#','#' }			//12
};
int book[20][20], max, mx, my;
int n=13, m=13;											//n行m列

int getnum(int i, int j)									   //统计当前点可消灭敌人个数的函数
{
	int sum, x, y;
	sum = 0;

	x = i, y = j;
	while (a[x][y] != '#')                                    //如果不是墙
	{
		if (a[x][y] == 'G')									  //如果是敌人
			sum++;
		x--;                                                  //向上统计
	}
	x = i, y = j;
	while (a[x][y] != '#')
	{
		if (a[x][y] == 'G')
			sum++;
		x++;												 //向下统计
	}
	x = i, y = j;
	while (a[x][y] != '#')
	{
		if (a[x][y] == 'G')
			sum++;
		y--;												 //向左统计
	}
	x = i, y = j;
	while (a[x][y] != '#')
	{
		if (a[x][y] == 'G')
			sum++;
		y++;												 //向右统计
	}

	return sum;
}
void dfs(int x, int y)
{
	int next[4][2] = {
		{ 0,1 },						     //向右走
		{ 1,0 },							 //向下走
		{ 0,-1 },							 //向左走
		{ -1,0 },							 //向上走
	};
	int k, sum, tx, ty;
	
	sum = getnum(x, y);									
	/*
		getnum():统计该点消灭敌人数。
		在dfs()内，表示计算当前点可消灭敌人个数
	*/
	if (sum > max)
	{
		max = sum;
		mx = x;
		my = y;
	}

	for (k = 0; k <= 3; k++)						   //枚举4个方向
	{
		tx = x + next[k][0];
		ty = y + next[k][1];

		if (tx<0 || tx>n - 1 || ty<0 || ty>m - 1)	   //越界则结束当次，进行下一方向
			continue;
		if (a[tx][ty] == '.'&&book[tx][ty] == 0)
		{
			book[tx][ty] = 1;                          //标记该点已经走过
			dfs(tx, ty);							   //开始尝试下一个点
		}
	}
	return;
	/*
		注：sum 为 dfs() 内变量，mx,my,max 为全局变量。
	*/
}
int main()
{
	int i, startx, starty;
	printf("输入起点: ");
	scanf_s("%d %d", &startx, &starty);
	book[startx][starty] = 1;

	max = getnum(startx, starty);                       //计算起点可消灭敌人数
	mx = startx;
	my = starty;
	dfs(startx, starty);             
	/*
		此处dfs()作用：
				访问所有点(92行)；
				计算所有点对应可消灭敌人个数（70行）；
				比较得出最多可消灭敌人数和对应坐标（75行）。
	*/

	printf("将炸弹放置在(%d,%d)，最多可以消灭 %d 个敌人\n", mx, my, max);
	getchar();
	getchar();
	return 0;
}