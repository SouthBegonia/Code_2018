/*
	程序功能：输入可以放置的数字（1~9），对所有盒子逐一进行放入数字的操作；
			 每到一个盒子前时，遵循从1~9优先顺序放置，进行类似全排列操作。
	深度优先搜索：解决当下该怎么做。
	深度优先搜索基本模型：
	void dfs(int step)
	{
		判断边界
		尝试下一种可能 for(i=1;i<=n;i++)
		{
			标记该种可能情况
			继续下一步 dfs(step+1)
			取消标记
		}
		返回
	}

*/
#include<stdio.h>
int a[10];                                       //待放入数字的盒子
int book[10];                                    //标记是否数字是否已经被放入
int n;                                           //可放入的数字（1~9,待输入）

void dfs(int step)                               // step表示站在第几个盒子面前
{
	int i;
	if (step == n + 1)                           // 前面的 n 个盒子已经放置好数字
	{
		
		for (i = 1; i <= n; i++)
			printf("%d ", a[i]);
		printf("\n");

		return;
	}

	for (i = 1; i <= n;i++)                       //站在step前，从1到n开始尝试（优先顺序）
	{
		if (book[i] == 0)                         //当前数字可以放置
		{
			a[step] = i;                          //盒子里放入数字
			book[i] = 1;                          //标记该数字已被放入

			dfs(step + 1);                      
			/*
				此时 step 盒子被放入数字，当下应该转到下一个盒子，即 step+1
			*/
			book[i] = 0;
			/*
				关键步骤！将刚才尝试的数字取回，才可进行下一步的尝试
			*/
		}
	}
	return;
}

int main()
{
	printf("输入 1~9 之间的整数：");
	scanf_s("%d", &n);
	dfs(1);                                         //首先对 1 号盒子进行尝试
	getchar();
	getchar();
	return 0;
}
/*
	例如：输入 2
		  输出： 1 2
				 2 1
	解释：函数依次会调用dfs(1),dfs(2),dfs(3);
			调用dfs(1)，for循环（当i=1)，第一个盒子先放入数字1，,后运行到31行执行 dfs(2);
				调用dfs(2)，for循环执行2次（数字1已经被放入1号盒子，故i=1无用，执行数字2），2号盒子放入数字2，31行调用dfs(3);
					调用到dfs(3)时候，满足14行条件(移到了空盒子)，则打印出1~n个盒子内的数，第一次 return；
				第一次 return 返回到dfs(2)的dfs(2),执行后续语句：取出当前盒子的数字(book[i]=0);退出for循环，执行41行第二次 return；
			第二次 return 返回到for(i=1)中dfs(1)的后续语句，取出第一个盒子里的数字。此时两个盒子里的数都被取出。
			dfs(1)函数中for循环 i=1 结束，得到结果：1 2
			注意！dfs(1)函数内的for循环开始执行 i=2 情况（见58行）。变为第一个盒子先放入数字 2
			后续执行得到结果： 2 1 。直到41行 return 退出dfs(1)函数，结束程序。
			
*/