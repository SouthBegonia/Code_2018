/*
	程序功能：设定10x10的地图a[][]（0为海，大于0的为陆地）；
			  需要计算出地图上的岛屿数 num，并把不同类的岛屿染色（赋予不同的负值）
	思路：依次检索地图上所有点，当遇到陆地（大于0），则调用dfs(x,y,color)函数进行染色，染色过程需要将同一岛屿内的陆地染成同色（相同的负值）；
		  当同一岛屿的陆地染成同色后，返回main函数继续依次的检索，因为地图上同岛屿的点被染色了，故被检索到那个点时则跳过。
*/
#include<stdio.h>
int a[51][51] = {
	{0,0,0,0,0,0,0,0,0,0,0},
	{0,1,2,1,0,0,0,0,0,2,3},
	{0,3,0,2,0,1,2,1,0,1,2},
	{0,4,0,1,0,1,2,3,2,0,1},
	{0,3,2,0,0,0,1,2,4,0,0},
	{0,0,0,0,0,0,0,1,5,3,0},
	{0,0,1,2,1,0,1,5,4,3,0},
	{0,0,1,2,3,1,3,6,2,1,0},
	{0,0,0,3,4,8,9,7,5,0,0},
	{0,0,0,0,3,7,8,6,0,1,2},
	{0,0,0,0,0,0,0,0,0,1,0},
};
int book[51][51], n=10, m=10, sum;
void dfs(int x, int y, int color)
{
	int next[4][2] = {
		{0, 1},
		{1, 0},
		{0, -1},
		{-1, 0},
	};
	int k, tx, ty;

	a[x][y] = color;										
	/*
		对a[x][y]这个格子进行染色，color 值即为 58行的 num--		
	*/
	for (k = 0; k <= 3; k++)								//对4个方向枚举
	{
		tx = x + next[k][0];
		ty = y + next[k][1];

		if (tx<1 || tx>n || ty<1 || ty>m)					//判断是否越界
			continue;
		if (a[tx][ty] > 0 && book[tx][ty] == 0)				//判断是否是陆地且未走过
		{
			sum++;
			book[tx][ty] = 1;
			dfs(tx, ty, color);
			/*
				当鉴定为临近的陆地（即这一类岛屿的一部分），则当前坐标改变，染色值 color不变，对该点染色且进行下一个点的判断。
			*/
		}
	}
	return;
}
int main()
{
	int i, j, num = 0;
	for (i = 1; i <= n; i++)								//对于每一个陆地（大于0的点）进行染色（dfs())
	{
		for (j = 1; j <= m; j++)
		{
			if (a[i][j] > 0)								
			{
				/*
					当检索到陆地(大于0)，则开始进行染色,对于已经染色的点（小于0）则跳过
				*/
				num--;										//当一类岛屿染色完毕后，染色值改变
				book[i][j] = 1;
				dfs(i, j, num);
				/*
					第一次执行dfs(1,1,-1)，即开始染色（29行为染色代码，将该陆地的值变为-1，记作第一个类型岛屿）
				*/
			}
		}
	}
	for (i = 1; i <= n; i++)
	{
		for (j = 1; j <= m; j++)
		{
			printf("%3d", a[i][j]);
		}
		printf("\n");
	}
	printf("全地图中的陆地面积为 %d \n", sum);
	printf("全地图共有 %d 个小岛。\n", -num);
	getchar();
	getchar();
	return 0;
}